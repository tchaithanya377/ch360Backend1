"""
Enhanced Attendance Load Tests for CampsHub360
Performance testing scripts using Locust for high-throughput scenarios
"""

from locust import HttpUser, task, between
import random
import uuid
import json
from datetime import datetime, timedelta


class AttendanceUser(HttpUser):
    """Base user class for attendance load testing"""
    wait_time = between(1, 3)
    
    def on_start(self):
        """Login and get authentication token"""
        # Login to get JWT token
        login_data = {
            "email": "test@example.com",
            "password": "testpassword"
        }
        response = self.client.post("/api/auth/login/", json=login_data)
        if response.status_code == 200:
            self.token = response.json()["access"]
            self.headers = {"Authorization": f"Bearer {self.token}"}
        else:
            self.token = None
            self.headers = {}
    
    def on_stop(self):
        """Cleanup after user stops"""
        pass


class QRCodeScanUser(AttendanceUser):
    """User that performs QR code scanning for attendance"""
    
    @task(10)
    def scan_qr_code(self):
        """Simulate QR code scanning"""
        if not self.token:
            return
        
        # Generate random student and session data
        student_id = str(uuid.uuid4())
        session_id = str(uuid.uuid4())
        
        # Create a mock QR token (in real scenario, this would be generated by the system)
        qr_data = {
            "qr_token": f"mock_qr_token_{session_id}",
            "student_id": student_id,
            "device_id": f"mobile_device_{random.randint(1000, 9999)}",
            "location_lat": round(random.uniform(17.0, 18.0), 6),
            "location_lng": round(random.uniform(78.0, 79.0), 6)
        }
        
        response = self.client.post(
            "/attendance/api/records/qr-scan/",
            json=qr_data,
            headers=self.headers
        )
        
        if response.status_code not in [200, 201]:
            print(f"QR scan failed: {response.status_code} - {response.text}")


class BulkAttendanceUser(AttendanceUser):
    """User that performs bulk attendance marking"""
    
    @task(5)
    def bulk_mark_attendance(self):
        """Simulate bulk attendance marking"""
        if not self.token:
            return
        
        # Generate bulk attendance data
        session_id = str(uuid.uuid4())
        attendance_data = []
        
        # Create 20-50 attendance records
        num_records = random.randint(20, 50)
        for i in range(num_records):
            student_id = str(uuid.uuid4())
            mark = random.choice(['present', 'absent', 'late', 'excused'])
            
            attendance_data.append({
                "student_id": student_id,
                "mark": mark,
                "reason": f"Bulk marking - {mark}",
                "device_id": f"bulk_device_{random.randint(1000, 9999)}"
            })
        
        bulk_data = {
            "session_id": session_id,
            "attendance_data": attendance_data,
            "source": "manual",
            "device_id": f"bulk_device_{random.randint(1000, 9999)}"
        }
        
        response = self.client.post(
            "/attendance/api/records/bulk-mark/",
            json=bulk_data,
            headers=self.headers
        )
        
        if response.status_code not in [200, 201]:
            print(f"Bulk marking failed: {response.status_code} - {response.text}")


class SessionManagementUser(AttendanceUser):
    """User that manages attendance sessions"""
    
    @task(3)
    def create_session(self):
        """Create a new attendance session"""
        if not self.token:
            return
        
        session_data = {
            "course_section": random.randint(1, 100),
            "faculty": str(uuid.uuid4()),
            "scheduled_date": (datetime.now() + timedelta(days=random.randint(1, 30))).strftime("%Y-%m-%d"),
            "start_datetime": (datetime.now() + timedelta(hours=random.randint(1, 8))).strftime("%Y-%m-%dT%H:%M:%S"),
            "end_datetime": (datetime.now() + timedelta(hours=random.randint(2, 9))).strftime("%Y-%m-%dT%H:%M:%S"),
            "room": f"Room {random.randint(1, 50)}",
            "makeup": random.choice([True, False]),
            "notes": f"Test session {random.randint(1, 1000)}"
        }
        
        response = self.client.post(
            "/attendance/api/sessions/",
            json=session_data,
            headers=self.headers
        )
        
        if response.status_code == 201:
            session_id = response.json()["id"]
            # Generate QR code for the session
            self.generate_qr_code(session_id)
    
    @task(2)
    def generate_qr_code(self, session_id=None):
        """Generate QR code for a session"""
        if not self.token:
            return
        
        if not session_id:
            session_id = str(uuid.uuid4())
        
        response = self.client.post(
            f"/attendance/api/sessions/{session_id}/generate-qr/",
            headers=self.headers
        )
        
        if response.status_code not in [200, 201]:
            print(f"QR generation failed: {response.status_code} - {response.text}")
    
    @task(1)
    def open_session(self):
        """Open an attendance session"""
        if not self.token:
            return
        
        session_id = str(uuid.uuid4())
        response = self.client.post(
            f"/attendance/api/sessions/{session_id}/open/",
            headers=self.headers
        )
        
        if response.status_code not in [200, 201]:
            print(f"Session open failed: {response.status_code} - {response.text}")
    
    @task(1)
    def close_session(self):
        """Close an attendance session"""
        if not self.token:
            return
        
        session_id = str(uuid.uuid4())
        response = self.client.post(
            f"/attendance/api/sessions/{session_id}/close/",
            headers=self.headers
        )
        
        if response.status_code not in [200, 201]:
            print(f"Session close failed: {response.status_code} - {response.text}")


class LeaveApplicationUser(AttendanceUser):
    """User that handles leave applications"""
    
    @task(2)
    def create_leave_application(self):
        """Create a leave application"""
        if not self.token:
            return
        
        leave_data = {
            "student": str(uuid.uuid4()),
            "leave_type": random.choice(['medical', 'personal', 'on_duty', 'emergency']),
            "start_date": (datetime.now() + timedelta(days=random.randint(1, 7))).strftime("%Y-%m-%d"),
            "end_date": (datetime.now() + timedelta(days=random.randint(2, 10))).strftime("%Y-%m-%d"),
            "reason": f"Test leave application {random.randint(1, 1000)}",
            "affects_attendance": random.choice([True, False]),
            "auto_apply_to_sessions": random.choice([True, False])
        }
        
        response = self.client.post(
            "/attendance/api/leave-applications/",
            json=leave_data,
            headers=self.headers
        )
        
        if response.status_code == 201:
            leave_id = response.json()["id"]
            # Approve or reject the leave application
            if random.choice([True, False]):
                self.approve_leave(leave_id)
            else:
                self.reject_leave(leave_id)
    
    @task(1)
    def approve_leave(self, leave_id=None):
        """Approve a leave application"""
        if not self.token:
            return
        
        if not leave_id:
            leave_id = str(uuid.uuid4())
        
        approval_data = {
            "decision_note": f"Approved - Test approval {random.randint(1, 1000)}"
        }
        
        response = self.client.post(
            f"/attendance/api/leave-applications/{leave_id}/approve/",
            json=approval_data,
            headers=self.headers
        )
        
        if response.status_code not in [200, 201]:
            print(f"Leave approval failed: {response.status_code} - {response.text}")
    
    @task(1)
    def reject_leave(self, leave_id=None):
        """Reject a leave application"""
        if not self.token:
            return
        
        if not leave_id:
            leave_id = str(uuid.uuid4())
        
        rejection_data = {
            "decision_note": f"Rejected - Test rejection {random.randint(1, 1000)}"
        }
        
        response = self.client.post(
            f"/attendance/api/leave-applications/{leave_id}/reject/",
            json=rejection_data,
            headers=self.headers
        )
        
        if response.status_code not in [200, 201]:
            print(f"Leave rejection failed: {response.status_code} - {response.text}")


class StatisticsUser(AttendanceUser):
    """User that queries attendance statistics"""
    
    @task(5)
    def get_student_summary(self):
        """Get student attendance summary"""
        if not self.token:
            return
        
        student_id = str(uuid.uuid4())
        params = {
            "student_id": student_id,
            "course_section_id": random.randint(1, 100),
            "start_date": (datetime.now() - timedelta(days=30)).strftime("%Y-%m-%d"),
            "end_date": datetime.now().strftime("%Y-%m-%d")
        }
        
        response = self.client.get(
            "/attendance/api/statistics/student-summary/",
            params=params,
            headers=self.headers
        )
        
        if response.status_code not in [200, 201]:
            print(f"Student summary failed: {response.status_code} - {response.text}")
    
    @task(3)
    def get_course_summary(self):
        """Get course attendance summary"""
        if not self.token:
            return
        
        params = {
            "course_section_id": random.randint(1, 100),
            "start_date": (datetime.now() - timedelta(days=30)).strftime("%Y-%m-%d"),
            "end_date": datetime.now().strftime("%Y-%m-%d")
        }
        
        response = self.client.get(
            "/attendance/api/statistics/course-summary/",
            params=params,
            headers=self.headers
        )
        
        if response.status_code not in [200, 201]:
            print(f"Course summary failed: {response.status_code} - {response.text}")
    
    @task(2)
    def list_sessions(self):
        """List attendance sessions"""
        if not self.token:
            return
        
        params = {
            "status": random.choice(['scheduled', 'open', 'closed']),
            "scheduled_date": datetime.now().strftime("%Y-%m-%d")
        }
        
        response = self.client.get(
            "/attendance/api/sessions/",
            params=params,
            headers=self.headers
        )
        
        if response.status_code not in [200, 201]:
            print(f"List sessions failed: {response.status_code} - {response.text}")
    
    @task(1)
    def list_attendance_records(self):
        """List attendance records"""
        if not self.token:
            return
        
        params = {
            "mark": random.choice(['present', 'absent', 'late', 'excused']),
            "source": random.choice(['manual', 'qr', 'biometric', 'rfid'])
        }
        
        response = self.client.get(
            "/attendance/api/records/",
            params=params,
            headers=self.headers
        )
        
        if response.status_code not in [200, 201]:
            print(f"List records failed: {response.status_code} - {response.text}")


class ExportUser(AttendanceUser):
    """User that performs data export operations"""
    
    @task(1)
    def export_attendance_data(self):
        """Export attendance data"""
        if not self.token:
            return
        
        export_data = {
            "format": random.choice(['csv', 'excel', 'pdf']),
            "start_date": (datetime.now() - timedelta(days=30)).strftime("%Y-%m-%d"),
            "end_date": datetime.now().strftime("%Y-%m-%d"),
            "course_sections": [random.randint(1, 100) for _ in range(random.randint(1, 5))],
            "include_details": random.choice([True, False]),
            "include_statistics": random.choice([True, False])
        }
        
        response = self.client.post(
            "/attendance/api/export/data/",
            json=export_data,
            headers=self.headers
        )
        
        if response.status_code not in [200, 201]:
            print(f"Export failed: {response.status_code} - {response.text}")


# Load test scenarios
class HighVolumeQRScanTest(HttpUser):
    """High-volume QR scanning test - 1000+ scans per second"""
    wait_time = between(0.1, 0.5)  # Very fast scanning
    
    def on_start(self):
        """Setup for high-volume testing"""
        self.token = "mock_token_for_high_volume_test"
        self.headers = {"Authorization": f"Bearer {self.token}"}
    
    @task(100)
    def rapid_qr_scan(self):
        """Rapid QR code scanning"""
        qr_data = {
            "qr_token": f"high_volume_token_{random.randint(1, 1000000)}",
            "student_id": str(uuid.uuid4()),
            "device_id": f"high_volume_device_{random.randint(1, 1000)}"
        }
        
        response = self.client.post(
            "/attendance/api/records/qr-scan/",
            json=qr_data,
            headers=self.headers
        )


class ConcurrentBulkMarkingTest(HttpUser):
    """Concurrent bulk marking test"""
    wait_time = between(0.5, 2.0)
    
    def on_start(self):
        """Setup for concurrent bulk marking"""
        self.token = "mock_token_for_bulk_test"
        self.headers = {"Authorization": f"Bearer {self.token}"}
    
    @task(20)
    def concurrent_bulk_mark(self):
        """Concurrent bulk attendance marking"""
        session_id = str(uuid.uuid4())
        attendance_data = []
        
        # Create 100-200 attendance records per bulk operation
        num_records = random.randint(100, 200)
        for i in range(num_records):
            attendance_data.append({
                "student_id": str(uuid.uuid4()),
                "mark": random.choice(['present', 'absent', 'late', 'excused']),
                "reason": f"Concurrent bulk marking - {i}"
            })
        
        bulk_data = {
            "session_id": session_id,
            "attendance_data": attendance_data,
            "source": "bulk_test"
        }
        
        response = self.client.post(
            "/attendance/api/records/bulk-mark/",
            json=bulk_data,
            headers=self.headers
        )


class MixedWorkloadTest(HttpUser):
    """Mixed workload test simulating real-world usage"""
    wait_time = between(1, 5)
    
    def on_start(self):
        """Setup for mixed workload"""
        self.token = "mock_token_for_mixed_test"
        self.headers = {"Authorization": f"Bearer {self.token}"}
    
    @task(30)
    def qr_scan(self):
        """QR code scanning (most common operation)"""
        qr_data = {
            "qr_token": f"mixed_token_{random.randint(1, 100000)}",
            "student_id": str(uuid.uuid4()),
            "device_id": f"mixed_device_{random.randint(1, 100)}"
        }
        
        self.client.post(
            "/attendance/api/records/qr-scan/",
            json=qr_data,
            headers=self.headers
        )
    
    @task(10)
    def bulk_mark(self):
        """Bulk marking (moderate frequency)"""
        session_id = str(uuid.uuid4())
        attendance_data = []
        
        num_records = random.randint(10, 50)
        for i in range(num_records):
            attendance_data.append({
                "student_id": str(uuid.uuid4()),
                "mark": random.choice(['present', 'absent', 'late', 'excused'])
            })
        
        bulk_data = {
            "session_id": session_id,
            "attendance_data": attendance_data
        }
        
        self.client.post(
            "/attendance/api/records/bulk-mark/",
            json=bulk_data,
            headers=self.headers
        )
    
    @task(5)
    def get_statistics(self):
        """Get statistics (moderate frequency)"""
        params = {
            "student_id": str(uuid.uuid4()),
            "course_section_id": random.randint(1, 100)
        }
        
        self.client.get(
            "/attendance/api/statistics/student-summary/",
            params=params,
            headers=self.headers
        )
    
    @task(2)
    def create_leave(self):
        """Create leave application (low frequency)"""
        leave_data = {
            "student": str(uuid.uuid4()),
            "leave_type": random.choice(['medical', 'personal', 'on_duty']),
            "start_date": (datetime.now() + timedelta(days=random.randint(1, 7))).strftime("%Y-%m-%d"),
            "end_date": (datetime.now() + timedelta(days=random.randint(2, 10))).strftime("%Y-%m-%d"),
            "reason": f"Mixed workload leave {random.randint(1, 1000)}"
        }
        
        self.client.post(
            "/attendance/api/leave-applications/",
            json=leave_data,
            headers=self.headers
        )
    
    @task(1)
    def export_data(self):
        """Export data (low frequency)"""
        export_data = {
            "format": "csv",
            "start_date": (datetime.now() - timedelta(days=7)).strftime("%Y-%m-%d"),
            "end_date": datetime.now().strftime("%Y-%m-%d")
        }
        
        self.client.post(
            "/attendance/api/export/data/",
            json=export_data,
            headers=self.headers
        )


# K6 JavaScript test script (alternative to Locust)
K6_TEST_SCRIPT = """
import http from 'k6/http';
import { check, sleep } from 'k6';
import { Rate } from 'k6/metrics';

// Custom metrics
const errorRate = new Rate('errors');

// Test configuration
export const options = {
  stages: [
    { duration: '2m', target: 100 }, // Ramp up to 100 users
    { duration: '5m', target: 100 }, // Stay at 100 users
    { duration: '2m', target: 200 }, // Ramp up to 200 users
    { duration: '5m', target: 200 }, // Stay at 200 users
    { duration: '2m', target: 0 },   // Ramp down to 0 users
  ],
  thresholds: {
    http_req_duration: ['p(95)<500'], // 95% of requests must complete below 500ms
    http_req_failed: ['rate<0.1'],    // Error rate must be below 10%
    errors: ['rate<0.1'],             // Custom error rate must be below 10%
  },
};

// Base URL
const BASE_URL = 'https://api.campushub360.com/attendance';

// Authentication token (in real scenario, this would be obtained via login)
const AUTH_TOKEN = 'your_jwt_token_here';

// Headers
const headers = {
  'Authorization': `Bearer ${AUTH_TOKEN}`,
  'Content-Type': 'application/json',
};

export default function() {
  // QR Code Scanning Test
  const qrScanPayload = JSON.stringify({
    qr_token: `test_qr_token_${Math.random()}`,
    student_id: generateUUID(),
    device_id: `device_${Math.floor(Math.random() * 1000)}`,
    location_lat: 17.3850 + Math.random() * 0.1,
    location_lng: 78.4867 + Math.random() * 0.1
  });

  const qrResponse = http.post(`${BASE_URL}/api/records/qr-scan/`, qrScanPayload, { headers });
  check(qrResponse, {
    'QR scan status is 200 or 201': (r) => r.status === 200 || r.status === 201,
    'QR scan response time < 500ms': (r) => r.timings.duration < 500,
  }) || errorRate.add(1);

  sleep(0.1);

  // Bulk Attendance Marking Test
  const attendanceData = [];
  const numRecords = Math.floor(Math.random() * 30) + 10; // 10-40 records
  
  for (let i = 0; i < numRecords; i++) {
    attendanceData.push({
      student_id: generateUUID(),
      mark: ['present', 'absent', 'late', 'excused'][Math.floor(Math.random() * 4)],
      reason: `Bulk marking ${i}`
    });
  }

  const bulkPayload = JSON.stringify({
    session_id: generateUUID(),
    attendance_data: attendanceData,
    source: 'manual',
    device_id: `bulk_device_${Math.floor(Math.random() * 1000)}`
  });

  const bulkResponse = http.post(`${BASE_URL}/api/records/bulk-mark/`, bulkPayload, { headers });
  check(bulkResponse, {
    'Bulk mark status is 200 or 201': (r) => r.status === 200 || r.status === 201,
    'Bulk mark response time < 1000ms': (r) => r.timings.duration < 1000,
  }) || errorRate.add(1);

  sleep(0.5);

  // Statistics Query Test
  const statsParams = {
    student_id: generateUUID(),
    course_section_id: Math.floor(Math.random() * 100) + 1,
    start_date: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString().split('T')[0],
    end_date: new Date().toISOString().split('T')[0]
  };

  const statsResponse = http.get(`${BASE_URL}/api/statistics/student-summary/`, { 
    headers,
    params: statsParams 
  });
  check(statsResponse, {
    'Stats query status is 200': (r) => r.status === 200,
    'Stats query response time < 300ms': (r) => r.timings.duration < 300,
  }) || errorRate.add(1);

  sleep(1);
}

// Helper function to generate UUID
function generateUUID() {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
    const r = Math.random() * 16 | 0;
    const v = c == 'x' ? r : (r & 0x3 | 0x8);
    return v.toString(16);
  });
}
"""

# Performance benchmarks and expectations
PERFORMANCE_BENCHMARKS = {
    "qr_scan": {
        "target_rps": 1000,  # 1000 QR scans per second
        "max_latency_p95": 200,  # 95% of requests under 200ms
        "max_latency_p99": 500,  # 99% of requests under 500ms
        "error_rate_threshold": 0.01  # Less than 1% errors
    },
    "bulk_mark": {
        "target_rps": 100,   # 100 bulk operations per second
        "max_latency_p95": 1000,  # 95% of requests under 1 second
        "max_latency_p99": 2000,  # 99% of requests under 2 seconds
        "error_rate_threshold": 0.05  # Less than 5% errors
    },
    "statistics_query": {
        "target_rps": 500,   # 500 queries per second
        "max_latency_p95": 300,  # 95% of requests under 300ms
        "max_latency_p99": 800,  # 99% of requests under 800ms
        "error_rate_threshold": 0.02  # Less than 2% errors
    },
    "session_management": {
        "target_rps": 50,    # 50 session operations per second
        "max_latency_p95": 500,  # 95% of requests under 500ms
        "max_latency_p99": 1000,  # 99% of requests under 1 second
        "error_rate_threshold": 0.03  # Less than 3% errors
    }
}

# Load test execution commands
LOAD_TEST_COMMANDS = {
    "locust_qr_scan": "locust -f attendance/load_tests_enhanced.py QRCodeScanUser --host=https://api.campushub360.com --users 1000 --spawn-rate 100 --run-time 10m",
    "locust_bulk_mark": "locust -f attendance/load_tests_enhanced.py BulkAttendanceUser --host=https://api.campushub360.com --users 200 --spawn-rate 20 --run-time 10m",
    "locust_mixed_workload": "locust -f attendance/load_tests_enhanced.py MixedWorkloadTest --host=https://api.campushub360.com --users 500 --spawn-rate 50 --run-time 15m",
    "k6_test": "k6 run attendance/k6_attendance_test.js",
    "high_volume_qr": "locust -f attendance/load_tests_enhanced.py HighVolumeQRScanTest --host=https://api.campushub360.com --users 2000 --spawn-rate 200 --run-time 5m"
}
